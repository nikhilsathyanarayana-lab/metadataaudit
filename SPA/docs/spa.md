# SPA architecture and navigation

## Shell and navigation
- `SPA/js/spa.js` initializes navigation by rendering the shared nav bar from `SPA/html/nav.html` and wiring up the page switcher buttons. Navigation state is reflected through `aria-pressed` toggles so screen readers understand which view is active.
- Page switcher buttons load in a locked state and only enable after either SubID shortcut (Select Apps or Audit All) is clicked, preventing navigation before any auth inputs exist.
- Each numbered tab (1–5) represents a view backed by its own HTML partial (`SPA/html/1.html`–`SPA/html/5.html`). When a tab is selected, the SPA fetches that partial with `cache: 'no-cache'`, injects it into the main container, and invokes a matching initializer module (`SPA/js/1.js`–`SPA/js/5.js`) if one exists.
- View 4 ships with a Pendo-styled "Subscriptions" card and canvas placeholder to host the first Chart.js visualization when the charting logic is added.
- The View 4 subscription progress list reports processed metadata coverage per SubID (`X out of Y`) using `metadataAggregations` app buckets for the numerator and the latest totals cached from `SPA/API/app_names.js` for the denominator so repeated app lookups after adding credentials keep the available-app count in sync.
- Each partial uses a shared `page-view` wrapper with a unique ID so cached DOM for one view cannot collide with another when sections are swapped back into the container.
- Loaded sections are memoized in a `Map` so revisiting a tab reuses existing DOM and skips redundant network fetches or initializers. Status text in the header (`[data-page-status]`) reports loading or error messages when a section is swapped. Views can optionally export an `onShow` handler to refresh data each time they are opened; the app selection preview uses this to respect credential changes without forcing a full reload.
- When the app selection preview re-renders, it reapplies any saved checkbox choices before enabling controls so returning to the tab preserves selections while reflecting updated credential fetches.
- `SPA/js/nav.js` handles fetching and rendering the top-level navigation chrome and marks the active SPA entry via `aria-current`. This keeps the SPA host page aligned with the rest of the site navigation while keeping markup separate from logic.
- To add a new SPA view, create `SPA/html/<id>.html` and `SPA/js/<id>.js`, then register the `<id>` button in `SPA/html/SPA.html` and extend the loader map in `SPA/js/spa.js`. Keep assets under `SPA/` so the rebuild can stay deployable alongside (or independent of) the legacy flow.

## Behavior and extensibility
- The SPA defaults to the first view on load and short-circuits re-renders when the active tab is selected again, preventing duplicate initializer calls. Each initializer can export `initSection(element)` to hydrate only the content relevant to its partial.
- View 3 (`SPA/js/3.js`) hydrates all four metadata tables (Visitor, Account, Custom, and Salesforce) with the SubID, app name, and app ID rows already selected on view 2, falling back to a fresh app name lookup only when no cached selections are available. After the tables render, `SPA/API/metadata.js` builds the next metadata call plan with the same credentials used for app discovery, queues the 7/23/150-day requests for every SubID + App ID row on the page, and runs the full queue in window order while exposing queue controls in the console. Metadata table rendering logs unexpected failures and drops a single status row across all four tables so the view never stays blank when upstream lookups fail. The same SubID/app/namespace rows are captured in a `tableData` array with "Pending..." lookback placeholders; `populateTables()` seeds it with the current selected apps across every namespace and logs them early in the SPA lifecycle so you can verify the population hook fired before other metadata work begins, and `processAPI()` overwrites each row's 7/30/180 buckets with sorted namespace field names merged from the latest 7/23/150-day aggregations (with duplicates removed) only after all buckets required for that window have finished processing so cached table data mirrors the rendered columns without early partials.
- Metadata table refreshes now flow through a single `renderTablesFromData()` helper that maps `tableData` into row templates and appends shared status rows, avoiding per-cell DOM queries or dataset wiring. Lookback columns update whenever `tableData` is modified so the DOM stays aligned with cached state after `processAPI()` finishes updating the cache.
- SPA logging favors concise `console.log` statements that echo the executing function name for SPA helpers so you can quickly trace which lifecycle call is running during SPA view loads.
- Section fetch failures (for example, missing HTML partials or network issues) surface both console errors and user-facing status text without breaking the rest of the shell. This makes it safe to add or iterate on new sections while keeping the overall SPA resilient.
- The app selection preview's Continue control (`#app-selection-continue-btn`) triggers the page switcher button for view 3 (`#page-switcher-btn-3`), letting users jump straight to the metadata tables after confirming at least one app selection.
- App selection snapshots (Sub ID, app name, app ID, and whether each row was selected) are cached in `SPA/js/2.js` when Continue is clicked so later SPA steps can reuse the chosen state without re-querying the table DOM.

## PDF exports
- Static PDF-ready assets live under `SPA/pdf/`. Use `pdf1.html` with `pdf/pdf.css` for a simple export shell that centers a 72pt "Overview" title at the top of the page.

## Data caching and queues
- SPA view 3 stores SubID → App ID lookups with per-window namespace buckets, timeseries starts, and value/count tallies for visitor/account/custom/Salesforce fields so recent metadata distributions can be reviewed from the console without separate app-level rollups. These `metadataAggregations` entries power the SPA metadata tables and exports.
- Metadata queues run through `SPA/API/metadata.js`, which builds call plans, sequences 7/23/150-day runs, and exposes console controls for print/inspect/rebuild/run. Queue executions respect window order so all 7-day calls finish before 23- or 150-day calls start.

## Console helpers
- **`window.tableData`**: Mirrors SPA view 3 rows with `{ subId, appName, appId, namespace, window7, window30, window180 }` objects so the rendered table state can be inspected or reused without DOM traversal.
- **`window.metadataQueue`**: Queues 7/23/150-day metadata aggregation calls for each SubID + App ID pair. `print()` logs queued pairs, `rebuild()` re-queues the current page selections, `inspect()` surfaces queue entries, `size()` reports the queue length, and `run(limit)` executes queued calls while logging each aggregation through `processAggregation()`.
